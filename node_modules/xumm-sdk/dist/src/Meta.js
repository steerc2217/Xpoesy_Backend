"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Meta = void 0;
const debug_1 = require("debug");
const fetch_ponyfill_1 = __importDefault(require("fetch-ponyfill"));
const { fetch, Request, Response, Headers } = fetch_ponyfill_1.default();
const os_1 = require("os");
const utils_1 = require("./utils");
const index_1 = require("./index");
const log = debug_1.debug('xumm-sdk:meta');
class Meta {
    constructor(apiKey, apiSecret) {
        this.isBrowser = false;
        this.jwtFlow = false;
        // Dependency injection: parent
        this.injected = false;
        log('Constructed');
        const uuidRe = new RegExp('^[a-f0-9]{8}\-[a-f0-9]{4}\-[a-f0-9]{4}\-[a-f0-9]{4}\-[a-f0-9]{12}$');
        const secret = {
            split: apiSecret.split(':'),
            uuidv4: ''
        };
        if (secret.split.length === 3 && secret.split.slice(0, 2).join(':') === 'xApp:OneTimeToken') {
            // xApp JWT flow
            secret.uuidv4 = secret.split[2];
            this.jwtFlow = true;
        }
        else {
            // Regular SDK/API calls
            secret.uuidv4 = apiSecret;
        }
        if (!uuidRe.test(apiKey) || !uuidRe.test(secret.uuidv4)) {
            if (!this.jwtFlow) {
                throw new Error('Invalid API Key and/or API Secret. Use dotenv or constructor params.');
            }
            else {
                throw new Error('Invalid API Key and/or OTT (One Time Token). ' +
                    'Provide OTT param (2nd param) or make sure `xAppToken` query param is present (Browser)');
            }
        }
        if (typeof global !== 'undefined' && Object.keys(global).indexOf('window') < 0) {
            log('Running in node');
        }
        else {
            console.log('XUMM SDK: Running in browser');
            this.isBrowser = true;
        }
        this.apiKey = apiKey;
        this.apiSecret = secret.uuidv4;
        if (this.jwtFlow) {
            // Eventloop: wait for _inject @ index.ts (XummSdk Constructor) to have happened
            Promise.resolve().then(() => this.authorize());
        }
        return this;
    }
    authorize() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const handleOttJwt = (JwtOttResponse) => {
                log('Resolved OTT, got JWT & OTT Data for xApp:', JwtOttResponse.app.name);
                this.jwt = JwtOttResponse.jwt;
                if (this === null || this === void 0 ? void 0 : this.invoker) {
                    if (this.invoker.constructor === index_1.XummSdkJwt) {
                        this.invoker._inject(JwtOttResponse.ott, this);
                    }
                }
            };
            if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {
                if (typeof window.localStorage['XummSdkJwt'] === 'string') {
                    const lsOttData = window.localStorage['XummSdkJwt'].split(':');
                    if (lsOttData[0] === this.apiSecret) {
                        // Restore from memory
                        console.log('Restoring OTT from localStorage:', this.apiSecret);
                        try {
                            const JwtOttResponse = JSON.parse(lsOttData.slice(1).join(':'));
                            handleOttJwt(JwtOttResponse);
                            return;
                        }
                        catch (e) {
                            console.log('Error restoring OTT Data (JWT) from localStorage', (_a = e) === null || _a === void 0 ? void 0 : _a.message);
                        }
                    }
                }
            }
            const authorizeData = yield this.call('authorize');
            if ((_c = (_b = authorizeData) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.code) {
                log(`Could not resolve API Key & OTT to JWT (already fetched? Unauthorized?)`);
                utils_1.throwIfError(authorizeData);
            }
            else if ((_d = authorizeData) === null || _d === void 0 ? void 0 : _d.jwt) {
                const JwtOttResponse = authorizeData;
                if (typeof window !== 'undefined' && typeof localStorage !== 'undefined') {
                    window.localStorage['XummSdkJwt'] = this.apiSecret + ':' + JSON.stringify(JwtOttResponse);
                }
                handleOttJwt(JwtOttResponse);
            }
            else {
                throw new Error(`Unexpected response for xApp JWT authorize request`);
            }
        });
    }
    call(endpoint, httpMethod = 'GET', data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const method = httpMethod.toUpperCase();
            try {
                let body;
                if (typeof data !== 'undefined') {
                    if (typeof data === 'object' && data !== null) {
                        body = JSON.stringify(data);
                    }
                    if (typeof data === 'string') {
                        body = data;
                    }
                }
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (!this.isBrowser) {
                    // TODO: Deno
                    Object.assign(headers, {
                        'User-Agent': `xumm-sdk/node (${os_1.hostname()}) node-fetch`
                    });
                }
                if (!this.jwtFlow) {
                    Object.assign(headers, {
                        'x-api-key': this.apiKey,
                        'x-api-secret': this.apiSecret
                    });
                }
                else {
                    if (endpoint === 'authorize') {
                        Object.assign(headers, {
                            'x-api-key': this.apiKey,
                            'x-api-ott': this.apiSecret
                        });
                    }
                    else {
                        Object.assign(headers, {
                            'Authorization': 'Bearer ' + this.jwt
                        });
                    }
                }
                const jwtEndpoints = [
                    'authorize',
                    'ping',
                    'curated-assets',
                    'rates',
                    'payload'
                ];
                const endpointType = this.jwtFlow && jwtEndpoints.indexOf(endpoint.split('/')[0]) > -1
                    ? 'xapp-jwt'
                    : 'platform';
                const request = yield fetch('https://xumm.app/api/v1/' + endpointType + '/' + endpoint, {
                    method,
                    body,
                    headers
                });
                const json = yield request.json();
                // log({json})
                return json;
            }
            catch (e) {
                const err = new Error(`Unexpected response from XUMM API [${method}:${endpoint}]`);
                err.stack = ((_a = e) === null || _a === void 0 ? void 0 : _a.stack) || undefined;
                throw err;
            }
        });
    }
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            const pong = yield this.call('ping');
            utils_1.throwIfError(pong);
            if (typeof pong.auth !== 'undefined') {
                return pong.auth;
            }
            const jwtPong = pong;
            if (typeof jwtPong.ott_uuidv4 !== 'undefined') {
                // return pong as xAppJwtPong
                return {
                    application: {
                        uuidv4: jwtPong.app_uuidv4,
                        name: jwtPong.app_name
                    },
                    jwtData: jwtPong
                };
                // xumm-sdk:sample   pong: {
                //   xumm-sdk:sample     pong: true,
                //   xumm-sdk:sample     ott_uuidv4: '6b2997ca-a6ad-4a9b-80d7-1ef7fd98be54',
                //   xumm-sdk:sample     app_uuidv4: '8525e32b-1bd0-4839-af2f-f794874a80b0',
                //   xumm-sdk:sample     app_name: 'XRP TipBot for Twitter, Reddit & Discord',
                //   xumm-sdk:sample     iat: 1631744211,
                //   xumm-sdk:sample     exp: 1631830611
                //   xumm-sdk:sample   }
            }
            throw new Error(`Unexpected response for ping request`);
        });
    }
    getCuratedAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('curated-assets');
        });
    }
    getRates(currencyCode) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('rates/' + currencyCode.trim().toUpperCase());
        });
    }
    getKycStatus(userTokenOrAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (userTokenOrAccount.trim().match(/^r/)) {
                const call = yield this.call('kyc-status/' + userTokenOrAccount.trim());
                return (call === null || call === void 0 ? void 0 : call.kycApproved) ? 'SUCCESSFUL' : 'NONE';
            }
            else {
                const call = yield this.call('kyc-status', 'POST', {
                    user_token: userTokenOrAccount
                });
                return (call === null || call === void 0 ? void 0 : call.kycStatus) || 'NONE';
            }
        });
    }
    getTransaction(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('xrpl-tx/' + txHash.trim());
        });
    }
    // Internal
    _inject(Invoker) {
        if (!this.injected) {
            this.invoker = Invoker;
        }
        else {
            throw new Error('Cannot `_inject` twice');
        }
    }
}
exports.Meta = Meta;
